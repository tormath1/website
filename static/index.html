<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>tormath1</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous" />
</head>

<body>

<h1>Table of content</h1>

<ul>
  <li><a href="#blog">Blog</a></li>
  <ul>
    <li><a href="#use-docker-compose-with-podman">Use docker-compose with Podman</a></li>
    <li><a href="#screensharing-on-wayland">Screensharing on Wayland</a></li>
    <li><a href="#playing-with-terraform-state">Playing with Terraform State</a></li>
  </ul>
  <li><a href="#links">Links</a></li>
</ul>

<h1 id="blog">Blog</h1>

<h2 id="use-docker-compose-with-podman">Use docker-compose with Podman - 19/01/21</h2>

From version 3.0, Podman <a href="https://www.redhat.com/sysadmin/podman-docker-compose">seems</a> fully compatible with Docker-Compose. I was curious to try it on the current version I have (2.2.1). Here's what I found !
<br>
We first need to activate the systemd unit provided by Podman:
<pre><code class="language-bash">
$ equery f libpod | grep service
/usr/lib/systemd/system/podman-auto-update.service
/usr/lib/systemd/system/podman.service
/usr/lib/systemd/user/podman-auto-update.service
/usr/lib/systemd/user/podman.service
/usr/share/man/man1/podman-system-service.1.bz2
$ sudo systemctl start podman.service
</code></pre>

It will create a unix Socket listening on <code class="language-none">%t/podman/podman.sock</code>.

Let's create a dummy docker-compose spec:

<pre><code class="language-yaml">
version: '3.7'
services:
  app:
    image: docker.io/alpine
    command: ["sleep", "60s"]
</code></pre>

I'm going to naively run everything:

<pre><code class="language-bash">
$ sudo DOCKER_HOST="unix:///run/podman/podman.sock" docker-compose up
Creating network "tmp_default" with the default driver
Creating tmp_app_1 ... error

ERROR: for tmp_app_1  cannot disconnect container 489f636118ca696ec03a6188fe8e027b56c1d1f1c9b04180a913a6ad603ff5b5 from networks as it is not running: container state improper

ERROR: for app  cannot disconnect container 489f636118ca696ec03a6188fe8e027b56c1d1f1c9b04180a913a6ad603ff5b5 from networks as it is not running: container state improper
ERROR: Encountered errors while bringing up the project.
</code></pre>

Oops, it seems the limitation of the current support of Docker-Compose on Podman 2.2.1 is reached. Let's try to manually start the container:

<pre><code class="language-bash">
$ sudo DOCKER_HOST="unix:///run/podman/podman.sock" docker-compose up --no-start
Creating network "tmp_default" with the default driver
Creating tmp_app_1 ... done
$ sudo podman ps -a
CONTAINER ID  IMAGE                            COMMAND    CREATED         STATUS   PORTS   NAMES
ed221fc06d6f  docker.io/library/alpine:latest  sleep 60s  46 seconds ago  Created          tmp_app_1
$ sudo podman start tmp_app_1
tmp_app_1
$ sudo podman exec -ti ed221fc06d6f ping google.com
PING google.com (216.58.213.78): 56 data bytes
64 bytes from 216.58.213.78: seq=0 ttl=113 time=2.952 ms
64 bytes from 216.58.213.78: seq=1 ttl=113 time=22.398 ms
64 bytes from 216.58.213.78: seq=2 ttl=113 time=7.604 ms
64 bytes from 216.58.213.78: seq=3 ttl=113 time=3.135 ms
...
</code></pre>

It works fine with the needs I have. It's enough to wait for the official release of Podman 3.0.0 on Gentoo ! 

<h2 id="screensharing-on-wayland">Screensharing on Wayland - 31/12/20</h2>

As a remote software engineer, video call is an essential requirement to work. When I moved from X11 to <a href="https://wayland.freedesktop.org/">Wayland</a>, Google Meet usage without any issues was mandatory: audio and video are not directly linked to Wayland, so no issue with them but screensharing is another thing. Basically to share a screen, you rely on X11 components so your browser / software must implements Wayland protocol in order to work in a non-X11 environment.
<br><br>

Here a couple of elements to keep in mind:
  <ul>
    <li>Install dbus with <code class="language-none">user-session</code> supports in order to have a session scoped dbus daemon
    <li>Compile Firefox with <code class="language-none">screencast</code> support to be able to use pipewire
    <li>Install (and start/enable) <code class="language-none">xdg-desktop-portal</code> with <code class="language-none">screencast</code> support
    <li>Install <code class="language-none">xdg-desktop-portal-wlr</code> for the wlroots XDG backend implementation
  </ul>

Now, the funny things:

  <ul>
    <li>Xwayland needs to be enabled, if not firefox will segfault
    <li>My whole system runs with <code class="language-none">libressl</code> instead of openssl (<a href="https://www.libressl.org/goals.html">https://www.libressl.org/goals.html</a>). NodeJS <a href="https://github.com/nodejs/node/issues/428">does not support yet libressl</a>, so you must compile NodeJS with the bundled SSL
  </ul>

Useful links:
  <ul>
    <li><a href="https://github.com/emersion/xdg-desktop-portal-wlr/wiki/Screencast-Compatibility">https://github.com/emersion/xdg-desktop-portal-wlr/wiki/Screencast-Compatibility</a>
    <li><a href="https://mozilla.github.io/webrtc-landing/">https://mozilla.github.io/webrtc-landing/</a>
    <li><a href="https://wiki.gentoo.org/wiki/Firefox">https://wiki.gentoo.org/wiki/Firefox</a>
  </ul>

<h3><i>Update - 14/01/20</i></h3>

So far, so good: no issue with screensharing on Firefox. I got one blocking point: Microsoft Teams. It happens that usage of Teams is required and it's currently impossible to attend to a Teams meeting using Firefox browser... Chromium is required.

Chromium wayland support for screencast is pretty new / unstable. Actually, the version I want is <a href="https://packages.gentoo.org/packages/www-client/chromium">masked</a> but I need this one because: 

<pre><code class="language-bash">
wayland? (
	dev-libs/wayland:=
	dev-libs/libffi:=
	screencast? ( media-video/pipewire:0/0.3 )
	x11-libs/gtk+:3[wayland,X]
	x11-libs/libdrm:=
	x11-libs/libxkbcommon:=
)
</code></pre>

As we can see, screencast requires pipewire-0.3. YES, it's a good thing, I was afraid to have only supports for pipewire-0.2. Which would be blocking for the Firefox installation...

After a <i>few</i> hours of compilation, Chromium is installed. The last thing to do is to add <code class="language-none">--enable-webrtc-pipewire-capturer</code> into <code class="language-none">/etc/chromium/default</code>.

<h2 id="playing-with-terraform-state">Playing with Terraform state - 26/12/20</h2>

To currently host this website, I use a GCP Load Balancer with a bucket as backend behind. The infrastructure is done <i>as code</i> with Terraform. I have some issues while creating the bucket using TF (domain name issues), so I used the GCP Console in order to create the bucket. Once done, I used <a href="https://github.com/cycloidio/terracognita">Terracognita</a>, a reverse Terraform in order to generate my HCL config and my Terraform state (TFState).

Everything went well, except that I fetched two other buckets and I was not interested to add them to this Terraform context. Using `terraform state` and its subcommands, I've been able to simply remove TF resources from the tfstate (without manual edition):

<pre><code class="language-bash">
$ terraform state --help
Usage: terraform state <subcommand> [options] [args]

  This command has subcommands for advanced state management.

  These subcommands can be used to slice and dice the Terraform state.
  This is sometimes necessary in advanced cases. For your safety, all
  state management commands that modify the state create a timestamped
  backup of the state prior to making modifications.

  The structure and output of the commands is specifically tailored to work
  well with the common Unix utilities such as grep, awk, etc. We recommend
  using those tools to perform more advanced state tasks.

Subcommands:
    list                List resources in the state
    mv                  Move an item in the state
    pull                Pull current state and output to stdout
    push                Update remote state from a local state file
    replace-provider    Replace provider in the state
    rm                  Remove instances from the state
    show                Show a resource in the state
$ terraform state rm google_storage_bucket.bfBqD
$ terraform state rm google_storage_bucket.SZMzR
</code></pre>

Then, I wanted to rename one of my resource:
<pre><code class="language-bash">
$ terraform state mv google_storage_bucket.xeFOT google_storage_bucket.static
</code></pre>

<h1 id="links">Links</h1>
<ul>
  <li><a href="https://github.com/tormath1">https://github.com/tormath1</a>
  <li><a href="https://twitter.com/tormath1">https://twitter.com/tormath1</a>
  <li><a href="https://www.linkedin.com/in/mathieu-tortuyaux-3b711b115/">https://www.linkedin.com/in/mathieu-tortuyaux-3b711b115/</a>
  <li><a href="https://tormath1.fr/resume.pdf">resume</a>
</ul>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-core.min.js" integrity="sha512-hqRrGU7ys5tkcqxx5FIZTBb7PkO2o3mU6U5+qB9b55kgMlBUT4J2wPwQfMCxeJW1fC8pBxuatxoH//z0FInhrA==" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-Q3qGP1uJL/B0sEmu57PKXjCirgPKMbg73OLRbTJ6lfHCVU5zkHqmcTI5EV2fSoPV1MHdKsCBE7m/aS6q0pPjRQ==" crossorigin="anonymous"></script>

</body>
</html>
